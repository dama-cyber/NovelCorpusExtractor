# NovelWeave ä¼˜ç‚¹èåˆæ–¹æ¡ˆ

åŸºäº [NovelWeave é¡¹ç›®](https://github.com/wordflowlab/novelweave) çš„ä¼˜ç§€è®¾è®¡ï¼Œæœ¬æ–‡æ¡£è¯´æ˜å¦‚ä½•å°†å…¶æ ¸å¿ƒä¼˜ç‚¹èå…¥åˆ° NovelCorpusExtractor ç³»ç»Ÿä¸­ã€‚

## ğŸ“‹ NovelWeave æ ¸å¿ƒä¼˜ç‚¹åˆ†æ

### 1. ä¸ƒæ­¥æ–¹æ³•è®ºï¼ˆSeven-Step Methodologyï¼‰

NovelWeave å®ç°äº†ç»“æ„åŒ–çš„åˆ›ä½œæµç¨‹ï¼Œä»åŸåˆ™å®šä¹‰åˆ°è´¨é‡éªŒè¯çš„å®Œæ•´é—­ç¯ï¼š

1. **`/constitution`** - å»ºç«‹æ ¸å¿ƒåˆ›ä½œåŸåˆ™ï¼ˆä¸å¯å¦¥åçš„å†™ä½œåŸåˆ™ï¼‰
2. **`/specify`** - å®šä¹‰æ•…äº‹éœ€æ±‚ï¼ˆç±»ä¼¼äº§å“éœ€æ±‚æ–‡æ¡£ PRDï¼‰
3. **`/clarify`** - å…³é”®æ¾„æ¸…ï¼ˆAI è¯†åˆ«æ­§ä¹‰ï¼Œç”Ÿæˆæœ€å¤š 5 ä¸ªå…³é”®é—®é¢˜ï¼‰
4. **`/plan`** - åˆ›ä½œè®¡åˆ’ï¼ˆå°†æŠ½è±¡éœ€æ±‚è½¬åŒ–ä¸ºå…·ä½“æŠ€æœ¯æ–¹æ¡ˆï¼‰
5. **`/tasks`** - ä»»åŠ¡åˆ†è§£ï¼ˆå°†è®¡åˆ’åˆ†è§£ä¸ºå¯æ‰§è¡Œçš„å†™ä½œä»»åŠ¡ï¼‰
6. **`/write`** - æ‰§è¡Œå†™ä½œï¼ˆåŸºäºä»»åŠ¡åˆ—è¡¨è¿›è¡Œå®é™…å†™ä½œï¼‰
7. **`/analyze`** - å…¨é¢éªŒè¯ï¼ˆéªŒè¯æƒ…èŠ‚ä¸€è‡´æ€§ã€æ—¶é—´çº¿å‡†ç¡®æ€§ç­‰ï¼‰

**ä¼˜ç‚¹**ï¼š
- âœ… ç»“æ„åŒ–æµç¨‹ï¼Œé¿å…é—æ¼å…³é”®æ­¥éª¤
- âœ… æ—©æœŸå‘ç°å’Œè§£å†³æ­§ä¹‰
- âœ… ä»æŠ½è±¡åˆ°å…·ä½“çš„æ¸è¿›å¼åˆ›ä½œ
- âœ… è´¨é‡ä¿è¯å†…ç½®åœ¨æµç¨‹ä¸­

### 2. Agent Skills ç³»ç»Ÿ

æ¨¡å—åŒ–çš„ AI çŸ¥è¯†ç³»ç»Ÿï¼Œæä¾›ä¸“ä¸šå†™ä½œæŠ€èƒ½ï¼š

- **å†…ç½®æŠ€èƒ½**ï¼š14 ä¸ªä¸“ä¸šå†™ä½œæŠ€èƒ½ï¼ˆç±»å‹çŸ¥è¯†ã€å†™ä½œæŠ€å·§ã€è´¨é‡ä¿è¯ç­‰ï¼‰
- **ä¸‰å±‚ç³»ç»Ÿ**ï¼š
  - **æ‰©å±•æŠ€èƒ½**ï¼šç³»ç»Ÿå†…ç½®çš„ä¸“ä¸šæŠ€èƒ½
  - **é¡¹ç›®æŠ€èƒ½**ï¼šé¡¹ç›®ç‰¹å®šçš„æŒ‡å¯¼åŸåˆ™ï¼ˆ`.agent/skills/`ï¼‰
  - **ä¸ªäººæŠ€èƒ½**ï¼šä¸ªäººå¯å¤ç”¨çš„çŸ¥è¯†åº“
- **æ™ºèƒ½æ¿€æ´»**ï¼šAI æ ¹æ®ä»»åŠ¡ä¸Šä¸‹æ–‡è‡ªåŠ¨é€‰æ‹©ç›¸å…³æŠ€èƒ½
- **è‡ªå®šä¹‰æŠ€èƒ½**ï¼šä½¿ç”¨ç®€å•çš„ Markdown åˆ›å»ºè‡ªå·±çš„ä¸“ä¸šçŸ¥è¯†æ¨¡å—

**ä¼˜ç‚¹**ï¼š
- âœ… æ¨¡å—åŒ–çŸ¥è¯†ç®¡ç†
- âœ… å¯æ‰©å±•å’Œå¯å¤ç”¨
- âœ… ä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„æŠ€èƒ½é€‰æ‹©
- âœ… å›¢é˜Ÿåä½œå‹å¥½

### 3. æ–œæ å‘½ä»¤ç³»ç»Ÿï¼ˆSlash Commandsï¼‰

ç±»ä¼¼ novel-writer CLI çš„å‘½ä»¤ç³»ç»Ÿï¼Œæä¾›å¿«é€Ÿæ“ä½œï¼š

- `/constitution` - åˆ›å»ºæˆ–ç¼–è¾‘åˆ›ä½œåŸåˆ™
- `/specify` - å®šä¹‰æ•…äº‹éœ€æ±‚
- `/clarify` - æ¾„æ¸…æ­§ä¹‰
- `/plan` - ç”Ÿæˆåˆ›ä½œè®¡åˆ’
- `/tasks` - ç®¡ç†ä»»åŠ¡åˆ—è¡¨
- `/write` - å¼€å§‹å†™ä½œ
- `/analyze` - éªŒè¯è´¨é‡

**ä¼˜ç‚¹**ï¼š
- âœ… å¿«é€Ÿè®¿é—®å¸¸ç”¨åŠŸèƒ½
- âœ… ç»Ÿä¸€çš„å‘½ä»¤æ¥å£
- âœ… æ”¯æŒè‡ªåŠ¨è¡¥å…¨å’Œæç¤º

### 4. è´¨é‡ä¿è¯ç³»ç»Ÿ

å†…ç½®çš„è´¨é‡éªŒè¯æœºåˆ¶ï¼š

- **ä¸€è‡´æ€§æ£€æŸ¥**ï¼šéªŒè¯è§’è‰²ç‰¹å¾ã€æ—¶é—´çº¿ã€äº‹å®
- **æƒ…èŠ‚è·Ÿè¸ª**ï¼šç¡®ä¿æ‰€æœ‰æƒ…èŠ‚çº¿ç´¢éƒ½å¾—åˆ°è§£å†³
- **æ—¶é—´çº¿ç®¡ç†**ï¼šæ—¶é—´é¡ºåºå‡†ç¡®æ€§éªŒè¯
- **é£æ ¼ä¸€è‡´æ€§**ï¼šä¿æŒç‹¬ç‰¹çš„å†™ä½œå£°éŸ³

**ä¼˜ç‚¹**ï¼š
- âœ… è‡ªåŠ¨åŒ–è´¨é‡æ£€æŸ¥
- âœ… æ—©æœŸå‘ç°é—®é¢˜
- âœ… å‡å°‘è¿”å·¥

## ğŸ”„ èåˆæ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šä¸ƒæ­¥æ–¹æ³•è®ºé›†æˆ

#### 1.1 åˆ›å»ºä¸ƒæ­¥æ–¹æ³•è®ºå·¥ä½œæµ

```python
# core/workflows/seven_step_workflow.py

from enum import Enum
from typing import Dict, List, Optional, Any
from .base import WorkflowBase, WorkflowStage

class SevenStepStage(str, Enum):
    """ä¸ƒæ­¥æ–¹æ³•è®ºé˜¶æ®µ"""
    CONSTITUTION = "constitution"  # å»ºç«‹åˆ›ä½œåŸåˆ™
    SPECIFY = "specify"            # å®šä¹‰æ•…äº‹éœ€æ±‚
    CLARIFY = "clarify"            # å…³é”®æ¾„æ¸…
    PLAN = "plan"                  # åˆ›ä½œè®¡åˆ’
    TASKS = "tasks"                # ä»»åŠ¡åˆ†è§£
    WRITE = "write"                # æ‰§è¡Œå†™ä½œ
    ANALYZE = "analyze"            # å…¨é¢éªŒè¯

class SevenStepWorkflow(WorkflowBase):
    """ä¸ƒæ­¥æ–¹æ³•è®ºå·¥ä½œæµ"""
    
    def get_stages(self) -> List[WorkflowStage]:
        """è·å–ä¸ƒæ­¥æ–¹æ³•è®ºé˜¶æ®µ"""
        return [
            WorkflowStage(
                name=SevenStepStage.CONSTITUTION.value,
                label="å»ºç«‹åˆ›ä½œåŸåˆ™",
                order=1,
                config={
                    "description": "å®šä¹‰ä¸å¯å¦¥åçš„å†™ä½œåŸåˆ™ã€é£æ ¼æŒ‡å—å’Œæ ¸å¿ƒä»·å€¼è§‚",
                    "output_type": "constitution",
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.SPECIFY.value,
                label="å®šä¹‰æ•…äº‹éœ€æ±‚",
                order=2,
                config={
                    "description": "å®šä¹‰è¦åˆ›å»ºçš„æ•…äº‹ã€ç›®æ ‡å—ä¼—å’ŒæˆåŠŸæ ‡å‡†",
                    "output_type": "specification",
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.CLARIFY.value,
                label="å…³é”®æ¾„æ¸…",
                order=3,
                config={
                    "description": "AI è¯†åˆ«è§„èŒƒä¸­çš„æ­§ä¹‰å¹¶ç”Ÿæˆæœ€å¤š 5 ä¸ªå…³é”®é—®é¢˜",
                    "output_type": "clarifications",
                    "max_questions": 5,
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.PLAN.value,
                label="åˆ›ä½œè®¡åˆ’",
                order=4,
                config={
                    "description": "å°†æŠ½è±¡éœ€æ±‚è½¬åŒ–ä¸ºå…·ä½“æŠ€æœ¯æ–¹æ¡ˆ",
                    "output_type": "plan",
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.TASKS.value,
                label="ä»»åŠ¡åˆ†è§£",
                order=5,
                config={
                    "description": "å°†è®¡åˆ’åˆ†è§£ä¸ºå¯æ‰§è¡Œçš„å†™ä½œä»»åŠ¡",
                    "output_type": "tasks",
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.WRITE.value,
                label="æ‰§è¡Œå†™ä½œ",
                order=6,
                config={
                    "description": "åŸºäºä»»åŠ¡åˆ—è¡¨è¿›è¡Œå®é™…å†™ä½œ",
                    "output_type": "content",
                    "iterative": True,
                    "required": True
                }
            ),
            WorkflowStage(
                name=SevenStepStage.ANALYZE.value,
                label="å…¨é¢éªŒè¯",
                order=7,
                config={
                    "description": "éªŒè¯æƒ…èŠ‚ä¸€è‡´æ€§ã€æ—¶é—´çº¿å‡†ç¡®æ€§ç­‰",
                    "output_type": "analysis",
                    "required": True
                }
            ),
        ]
    
    async def expand_stage(self, stage: WorkflowStage, parent_card_id: str) -> Dict[str, Any]:
        """æ‰©å±•é˜¶æ®µ"""
        if stage.name == SevenStepStage.CONSTITUTION.value:
            return await self._create_constitution(parent_card_id)
        elif stage.name == SevenStepStage.SPECIFY.value:
            return await self._create_specification(parent_card_id)
        elif stage.name == SevenStepStage.CLARIFY.value:
            return await self._create_clarifications(parent_card_id)
        elif stage.name == SevenStepStage.PLAN.value:
            return await self._create_plan(parent_card_id)
        elif stage.name == SevenStepStage.TASKS.value:
            return await self._create_tasks(parent_card_id)
        elif stage.name == SevenStepStage.WRITE.value:
            return await self._execute_writing(parent_card_id)
        elif stage.name == SevenStepStage.ANALYZE.value:
            return await self._analyze_quality(parent_card_id)
    
    async def _create_constitution(self, parent_card_id: str) -> Dict[str, Any]:
        """åˆ›å»ºåˆ›ä½œåŸåˆ™"""
        # è·å–é¡¹ç›®ä¸Šä¸‹æ–‡
        context = self._get_project_context()
        
        prompt = f"""è¯·ä¸ºè¿™ä¸ªå°è¯´é¡¹ç›®å»ºç«‹åˆ›ä½œåŸåˆ™ï¼ˆConstitutionï¼‰ã€‚

åˆ›ä½œåŸåˆ™æ˜¯ä¸å¯å¦¥åçš„å†™ä½œåŸåˆ™ã€é£æ ¼æŒ‡å—å’Œæ ¸å¿ƒä»·å€¼è§‚ï¼Œå°†æŒ‡å¯¼æ•´ä¸ªåˆ›ä½œè¿‡ç¨‹ã€‚

é¡¹ç›®ä¸Šä¸‹æ–‡ï¼š
{context}

è¯·ç”Ÿæˆä»¥ä¸‹å†…å®¹ï¼š
1. æ ¸å¿ƒåˆ›ä½œåŸåˆ™ï¼ˆ3-5 æ¡ï¼‰
2. é£æ ¼æŒ‡å—ï¼ˆè¯­è¨€é£æ ¼ã€å™äº‹è§†è§’ç­‰ï¼‰
3. æ ¸å¿ƒä»·å€¼è§‚ï¼ˆæ•…äº‹è¦ä¼ è¾¾çš„ä¸»é¢˜å’Œä»·å€¼è§‚ï¼‰
4. ä¸å¯å¦¥åçš„è§„åˆ™ï¼ˆå¿…é¡»éµå®ˆçš„è§„åˆ™ï¼‰

ä»¥ç»“æ„åŒ–çš„æ ¼å¼è¾“å‡ºã€‚"""
        
        result = await self.llm_client.generate(prompt)
        
        # åˆ›å»ºå¡ç‰‡
        card = self.card_manager.create_card(
            self.project_id,
            "constitution",
            {
                "content": result,
                "stage": "constitution",
                "parent_id": parent_card_id
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "stage": "constitution"
        }
    
    async def _create_specification(self, parent_card_id: str) -> Dict[str, Any]:
        """åˆ›å»ºæ•…äº‹éœ€æ±‚è§„èŒƒ"""
        # è·å–åˆ›ä½œåŸåˆ™
        constitution_card = self.card_manager.get_card(parent_card_id)
        constitution = constitution_card.get('content', {})
        
        prompt = f"""åŸºäºä»¥ä¸‹åˆ›ä½œåŸåˆ™ï¼Œå®šä¹‰è¯¦ç»†çš„æ•…äº‹éœ€æ±‚è§„èŒƒï¼ˆSpecificationï¼‰ã€‚

åˆ›ä½œåŸåˆ™ï¼š
{constitution}

è¯·ç”Ÿæˆç±»ä¼¼äº§å“éœ€æ±‚æ–‡æ¡£ï¼ˆPRDï¼‰çš„æ•…äº‹è§„èŒƒï¼ŒåŒ…æ‹¬ï¼š
1. æ•…äº‹æ¦‚è¿°ï¼ˆä¸€å¥è¯æ¢—æ¦‚ï¼‰
2. ç›®æ ‡å—ä¼—
3. æ•…äº‹ç±»å‹å’Œé£æ ¼
4. æ ¸å¿ƒå†²çªå’Œä¸»é¢˜
5. ä¸»è¦è§’è‰²ï¼ˆç®€è¦æè¿°ï¼‰
6. æ•…äº‹ç»“æ„ï¼ˆä¸‰å¹•å¼/è‹±é›„ä¹‹æ—…ç­‰ï¼‰
7. æˆåŠŸæ ‡å‡†ï¼ˆå¦‚ä½•åˆ¤æ–­æ•…äº‹æˆåŠŸï¼‰

ä»¥ç»“æ„åŒ–çš„æ ¼å¼è¾“å‡ºã€‚"""
        
        result = await self.llm_client.generate(prompt)
        
        card = self.card_manager.create_card(
            self.project_id,
            "specification",
            {
                "content": result,
                "stage": "specify",
                "parent_id": parent_card_id
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "stage": "specify"
        }
    
    async def _create_clarifications(self, parent_card_id: str) -> Dict[str, Any]:
        """åˆ›å»ºå…³é”®æ¾„æ¸…é—®é¢˜"""
        # è·å–è§„èŒƒ
        spec_card = self.card_manager.get_card(parent_card_id)
        specification = spec_card.get('content', {})
        
        prompt = f"""åˆ†æä»¥ä¸‹æ•…äº‹è§„èŒƒï¼Œè¯†åˆ«å¯èƒ½å­˜åœ¨çš„æ­§ä¹‰å’Œæ¨¡ç³Šä¹‹å¤„ã€‚

æ•…äº‹è§„èŒƒï¼š
{specification}

è¯·ç”Ÿæˆæœ€å¤š 5 ä¸ªå…³é”®é—®é¢˜ï¼Œè¿™äº›é—®é¢˜éœ€è¦æ¾„æ¸…ä»¥ç¡®ä¿åç»­åˆ›ä½œé¡ºåˆ©è¿›è¡Œã€‚
æ¯ä¸ªé—®é¢˜åº”è¯¥ï¼š
1. é’ˆå¯¹è§„èŒƒä¸­çš„å…·ä½“æ¨¡ç³Šç‚¹
2. å¯¹åç»­åˆ›ä½œæœ‰é‡è¦å½±å“
3. éœ€è¦æ˜ç¡®çš„ç­”æ¡ˆ

æ ¼å¼ï¼š
é—®é¢˜1ï¼š[é—®é¢˜æè¿°]
é—®é¢˜2ï¼š[é—®é¢˜æè¿°]
...

ç„¶åï¼Œè¯·ä¸ºæ¯ä¸ªé—®é¢˜æä¾›å»ºè®®çš„ç­”æ¡ˆé€‰é¡¹ï¼ˆå¦‚æœæœ‰ï¼‰ã€‚"""
        
        result = await self.llm_client.generate(prompt)
        
        card = self.card_manager.create_card(
            self.project_id,
            "clarifications",
            {
                "content": result,
                "stage": "clarify",
                "parent_id": parent_card_id,
                "questions": self._extract_questions(result)
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "questions": self._extract_questions(result),
            "stage": "clarify"
        }
    
    async def _create_plan(self, parent_card_id: str) -> Dict[str, Any]:
        """åˆ›å»ºåˆ›ä½œè®¡åˆ’"""
        # è·å–å‰é¢çš„æ‰€æœ‰é˜¶æ®µå†…å®¹
        context = self._get_all_previous_stages(parent_card_id)
        
        prompt = f"""åŸºäºä»¥ä¸‹ä¿¡æ¯ï¼Œåˆ›å»ºè¯¦ç»†çš„åˆ›ä½œè®¡åˆ’ï¼ˆPlanï¼‰ã€‚

é¡¹ç›®ä¸Šä¸‹æ–‡ï¼š
{context}

è¯·å°†æŠ½è±¡çš„éœ€æ±‚è½¬åŒ–ä¸ºå…·ä½“çš„æŠ€æœ¯æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š
1. ç« èŠ‚ç»“æ„ï¼ˆç« èŠ‚æ•°é‡å’Œå¤§è‡´å†…å®¹ï¼‰
2. è§’è‰²å¼§çº¿ï¼ˆä¸»è¦è§’è‰²çš„æˆé•¿è½¨è¿¹ï¼‰
3. ä¸–ç•Œè§‚æ„å»ºï¼ˆå¦‚æœéœ€è¦ï¼‰
4. æƒ…èŠ‚æ—¶é—´çº¿ï¼ˆä¸»è¦äº‹ä»¶çš„æ—¶é—´é¡ºåºï¼‰
5. ä¼ç¬”å¸ƒå±€ï¼ˆå…³é”®ä¼ç¬”çš„åŸ‹è®¾å’Œå›æ”¶ï¼‰
6. å†™ä½œç­–ç•¥ï¼ˆå¦‚ä½•å®ç°åˆ›ä½œåŸåˆ™å’Œè§„èŒƒï¼‰

ä»¥ç»“æ„åŒ–çš„æ ¼å¼è¾“å‡ºã€‚"""
        
        result = await self.llm_client.generate(prompt)
        
        card = self.card_manager.create_card(
            self.project_id,
            "plan",
            {
                "content": result,
                "stage": "plan",
                "parent_id": parent_card_id
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "stage": "plan"
        }
    
    async def _create_tasks(self, parent_card_id: str) -> Dict[str, Any]:
        """åˆ›å»ºä»»åŠ¡åˆ†è§£"""
        # è·å–è®¡åˆ’
        plan_card = self.card_manager.get_card(parent_card_id)
        plan = plan_card.get('content', {})
        
        prompt = f"""å°†ä»¥ä¸‹åˆ›ä½œè®¡åˆ’åˆ†è§£ä¸ºå¯æ‰§è¡Œçš„å†™ä½œä»»åŠ¡ï¼ˆTasksï¼‰ã€‚

åˆ›ä½œè®¡åˆ’ï¼š
{plan}

è¯·åˆ›å»ºä»»åŠ¡åˆ—è¡¨ï¼Œæ¯ä¸ªä»»åŠ¡åº”è¯¥ï¼š
1. æœ‰æ˜ç¡®çš„æè¿°
2. æœ‰ä¼˜å…ˆçº§ï¼ˆé«˜/ä¸­/ä½ï¼‰
3. æœ‰ä¾èµ–å…³ç³»ï¼ˆå¦‚æœæœ‰ï¼‰
4. æœ‰ä¼°ç®—çš„å·¥ä½œé‡
5. æœ‰éªŒæ”¶æ ‡å‡†

ä»»åŠ¡åº”è¯¥æŒ‰ç…§æ‰§è¡Œé¡ºåºæ’åˆ—ï¼Œå¹¶è€ƒè™‘ä¾èµ–å…³ç³»ã€‚"""
        
        result = await self.llm_client.generate(prompt)
        
        card = self.card_manager.create_card(
            self.project_id,
            "tasks",
            {
                "content": result,
                "stage": "tasks",
                "parent_id": parent_card_id,
                "tasks": self._extract_tasks(result)
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "tasks": self._extract_tasks(result),
            "stage": "tasks"
        }
    
    async def _execute_writing(self, parent_card_id: str) -> Dict[str, Any]:
        """æ‰§è¡Œå†™ä½œ"""
        # è·å–ä»»åŠ¡åˆ—è¡¨å’Œæ‰€æœ‰ä¸Šä¸‹æ–‡
        context = self._get_all_previous_stages(parent_card_id)
        tasks_card = self.card_manager.get_card(parent_card_id)
        tasks = tasks_card.get('tasks', [])
        
        # é€‰æ‹©ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„ä»»åŠ¡
        next_task = self._get_next_task(tasks)
        
        if not next_task:
            return {
                "message": "æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆ",
                "stage": "write",
                "completed": True
            }
        
        prompt = f"""åŸºäºä»¥ä¸‹ä¸Šä¸‹æ–‡ï¼Œæ‰§è¡Œå†™ä½œä»»åŠ¡ã€‚

é¡¹ç›®ä¸Šä¸‹æ–‡ï¼š
{context}

å½“å‰ä»»åŠ¡ï¼š
{next_task}

è¯·æŒ‰ç…§åˆ›ä½œåŸåˆ™å’Œè§„èŒƒï¼Œå®Œæˆè¿™ä¸ªå†™ä½œä»»åŠ¡ã€‚
è¾“å‡ºåº”è¯¥ï¼š
1. ç¬¦åˆåˆ›ä½œåŸåˆ™
2. ç¬¦åˆæ•…äº‹è§„èŒƒ
3. ç¬¦åˆåˆ›ä½œè®¡åˆ’
4. è¾¾åˆ°ä»»åŠ¡çš„éªŒæ”¶æ ‡å‡†"""
        
        result = await self.llm_client.generate(prompt)
        
        # åˆ›å»ºå†…å®¹å¡ç‰‡
        card = self.card_manager.create_card(
            self.project_id,
            "content",
            {
                "content": result,
                "stage": "write",
                "parent_id": parent_card_id,
                "task_id": next_task.get('id'),
                "task_description": next_task.get('description')
            }
        )
        
        # æ›´æ–°ä»»åŠ¡çŠ¶æ€
        self._mark_task_completed(next_task['id'])
        
        return {
            "card_id": card['id'],
            "content": result,
            "task": next_task,
            "stage": "write",
            "has_more_tasks": len([t for t in tasks if not t.get('completed')]) > 0
        }
    
    async def _analyze_quality(self, parent_card_id: str) -> Dict[str, Any]:
        """å…¨é¢éªŒè¯è´¨é‡"""
        # è·å–æ‰€æœ‰å·²å†™å†…å®¹
        all_content = self._get_all_written_content(parent_card_id)
        context = self._get_all_previous_stages(parent_card_id)
        
        prompt = f"""å¯¹ä»¥ä¸‹åˆ›ä½œå†…å®¹è¿›è¡Œå…¨é¢è´¨é‡éªŒè¯ï¼ˆAnalysisï¼‰ã€‚

é¡¹ç›®ä¸Šä¸‹æ–‡ï¼š
{context}

å·²å†™å†…å®¹ï¼š
{all_content}

è¯·éªŒè¯ä»¥ä¸‹æ–¹é¢ï¼š
1. **æƒ…èŠ‚ä¸€è‡´æ€§**ï¼šæ£€æŸ¥æƒ…èŠ‚é€»è¾‘æ˜¯å¦ä¸€è‡´ï¼Œæ˜¯å¦æœ‰çŸ›ç›¾
2. **æ—¶é—´çº¿å‡†ç¡®æ€§**ï¼šéªŒè¯äº‹ä»¶çš„æ—¶é—´é¡ºåºæ˜¯å¦æ­£ç¡®
3. **è§’è‰²å‘å±•**ï¼šæ£€æŸ¥è§’è‰²è¡Œä¸ºæ˜¯å¦ç¬¦åˆè®¾å®šï¼Œè§’è‰²å¼§çº¿æ˜¯å¦å®Œæ•´
4. **åˆ›ä½œåŸåˆ™éµå¾ª**ï¼šéªŒè¯æ˜¯å¦éµå¾ªäº†åˆ›ä½œåŸåˆ™
5. **è§„èŒƒç¬¦åˆåº¦**ï¼šæ£€æŸ¥æ˜¯å¦ç¬¦åˆæ•…äº‹è§„èŒƒ
6. **ä¼ç¬”å¤„ç†**ï¼šæ£€æŸ¥ä¼ç¬”æ˜¯å¦åˆç†åŸ‹è®¾å’Œå›æ”¶
7. **é£æ ¼ä¸€è‡´æ€§**ï¼šéªŒè¯å†™ä½œé£æ ¼æ˜¯å¦ä¸€è‡´

å¯¹äºå‘ç°çš„é—®é¢˜ï¼Œè¯·æä¾›ï¼š
- é—®é¢˜æè¿°
- é—®é¢˜ä½ç½®ï¼ˆç« èŠ‚/æ®µè½ï¼‰
- ä¸¥é‡ç¨‹åº¦ï¼ˆé«˜/ä¸­/ä½ï¼‰
- ä¿®å¤å»ºè®®"""
        
        result = await self.llm_client.generate(prompt)
        
        card = self.card_manager.create_card(
            self.project_id,
            "analysis",
            {
                "content": result,
                "stage": "analyze",
                "parent_id": parent_card_id,
                "issues": self._extract_issues(result)
            }
        )
        
        return {
            "card_id": card['id'],
            "content": result,
            "issues": self._extract_issues(result),
            "stage": "analyze"
        }
    
    def _get_project_context(self) -> str:
        """è·å–é¡¹ç›®ä¸Šä¸‹æ–‡"""
        # å®ç°è·å–é¡¹ç›®ä¸Šä¸‹æ–‡é€»è¾‘
        pass
    
    def _get_all_previous_stages(self, current_card_id: str) -> str:
        """è·å–æ‰€æœ‰å‰é¢é˜¶æ®µçš„å†…å®¹"""
        # å®ç°è·å–å‰é¢é˜¶æ®µå†…å®¹çš„é€»è¾‘
        pass
    
    def _extract_questions(self, text: str) -> List[Dict]:
        """ä»æ–‡æœ¬ä¸­æå–é—®é¢˜"""
        # å®ç°é—®é¢˜æå–é€»è¾‘
        pass
    
    def _extract_tasks(self, text: str) -> List[Dict]:
        """ä»æ–‡æœ¬ä¸­æå–ä»»åŠ¡"""
        # å®ç°ä»»åŠ¡æå–é€»è¾‘
        pass
    
    def _get_next_task(self, tasks: List[Dict]) -> Optional[Dict]:
        """è·å–ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„ä»»åŠ¡"""
        # å®ç°ä»»åŠ¡é€‰æ‹©é€»è¾‘
        pass
    
    def _mark_task_completed(self, task_id: str):
        """æ ‡è®°ä»»åŠ¡ä¸ºå·²å®Œæˆ"""
        # å®ç°ä»»åŠ¡çŠ¶æ€æ›´æ–°é€»è¾‘
        pass
    
    def _get_all_written_content(self, parent_card_id: str) -> str:
        """è·å–æ‰€æœ‰å·²å†™å†…å®¹"""
        # å®ç°è·å–å·²å†™å†…å®¹çš„é€»è¾‘
        pass
    
    def _extract_issues(self, text: str) -> List[Dict]:
        """ä»åˆ†ææ–‡æœ¬ä¸­æå–é—®é¢˜"""
        # å®ç°é—®é¢˜æå–é€»è¾‘
        pass
```

### æ–¹æ¡ˆäºŒï¼šAgent Skills ç³»ç»Ÿé›†æˆ

#### 2.1 åˆ›å»º Agent Skills ç³»ç»Ÿ

```python
# core/agent_skills.py

from typing import Dict, List, Optional, Any
from pathlib import Path
from enum import Enum
import yaml
import logging

logger = logging.getLogger(__name__)

class SkillLevel(str, Enum):
    """æŠ€èƒ½å±‚çº§"""
    EXTENSION = "extension"  # æ‰©å±•æŠ€èƒ½ï¼ˆç³»ç»Ÿå†…ç½®ï¼‰
    PROJECT = "project"      # é¡¹ç›®æŠ€èƒ½
    PERSONAL = "personal"    # ä¸ªäººæŠ€èƒ½

class AgentSkill:
    """Agent æŠ€èƒ½"""
    
    def __init__(
        self,
        id: str,
        name: str,
        description: str,
        content: str,
        level: SkillLevel,
        tags: List[str] = None,
        activation_keywords: List[str] = None
    ):
        self.id = id
        self.name = name
        self.description = description
        self.content = content
        self.level = level
        self.tags = tags or []
        self.activation_keywords = activation_keywords or []
    
    def to_dict(self) -> Dict:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "content": self.content,
            "level": self.level.value,
            "tags": self.tags,
            "activation_keywords": self.activation_keywords
        }
    
    @classmethod
    def from_markdown(cls, file_path: Path, level: SkillLevel) -> 'AgentSkill':
        """ä» Markdown æ–‡ä»¶åŠ è½½æŠ€èƒ½"""
        content = file_path.read_text(encoding='utf-8')
        
        # è§£æ Markdown å…ƒæ•°æ®ï¼ˆYAML front matterï¼‰
        parts = content.split('---', 2)
        if len(parts) >= 3:
            metadata = yaml.safe_load(parts[1])
            content = parts[2].strip()
        else:
            metadata = {}
            content = content.strip()
        
        # ä»æ–‡ä»¶åè·å– ID
        skill_id = file_path.stem
        
        return cls(
            id=skill_id,
            name=metadata.get('name', skill_id),
            description=metadata.get('description', ''),
            content=content,
            level=level,
            tags=metadata.get('tags', []),
            activation_keywords=metadata.get('activation_keywords', [])
        )

class AgentSkillsManager:
    """Agent Skills ç®¡ç†å™¨"""
    
    def __init__(self, project_root: Optional[Path] = None):
        self.project_root = project_root or Path.cwd()
        self.skills: Dict[str, AgentSkill] = {}
        self._load_skills()
    
    def _load_skills(self):
        """åŠ è½½æ‰€æœ‰æŠ€èƒ½"""
        # åŠ è½½æ‰©å±•æŠ€èƒ½
        extension_skills_dir = Path(__file__).parent.parent / "agent_skills" / "extension"
        if extension_skills_dir.exists():
            self._load_skills_from_dir(extension_skills_dir, SkillLevel.EXTENSION)
        
        # åŠ è½½é¡¹ç›®æŠ€èƒ½
        project_skills_dir = self.project_root / ".agent" / "skills"
        if project_skills_dir.exists():
            self._load_skills_from_dir(project_skills_dir, SkillLevel.PROJECT)
        
        # åŠ è½½ä¸ªäººæŠ€èƒ½
        personal_skills_dir = Path.home() / ".novelweave" / "skills"
        if personal_skills_dir.exists():
            self._load_skills_from_dir(personal_skills_dir, SkillLevel.PERSONAL)
    
    def _load_skills_from_dir(self, skills_dir: Path, level: SkillLevel):
        """ä»ç›®å½•åŠ è½½æŠ€èƒ½"""
        for md_file in skills_dir.glob("*.md"):
            try:
                skill = AgentSkill.from_markdown(md_file, level)
                self.skills[skill.id] = skill
                logger.info(f"Loaded skill: {skill.name} ({level.value})")
            except Exception as e:
                logger.error(f"Failed to load skill from {md_file}: {e}")
    
    def get_skill(self, skill_id: str) -> Optional[AgentSkill]:
        """è·å–æŠ€èƒ½"""
        return self.skills.get(skill_id)
    
    def list_skills(self, level: Optional[SkillLevel] = None, tags: List[str] = None) -> List[AgentSkill]:
        """åˆ—å‡ºæŠ€èƒ½"""
        skills = list(self.skills.values())
        
        if level:
            skills = [s for s in skills if s.level == level]
        
        if tags:
            skills = [s for s in skills if any(tag in s.tags for tag in tags)]
        
        return skills
    
    def activate_skills(self, context: str, task_description: str) -> List[AgentSkill]:
        """æ ¹æ®ä¸Šä¸‹æ–‡å’Œä»»åŠ¡æè¿°æ¿€æ´»ç›¸å…³æŠ€èƒ½"""
        activated = []
        
        # è®¡ç®—æ¯ä¸ªæŠ€èƒ½çš„åŒ¹é…åº¦
        for skill in self.skills.values():
            score = self._calculate_relevance_score(skill, context, task_description)
            if score > 0.3:  # é˜ˆå€¼å¯é…ç½®
                activated.append((skill, score))
        
        # æŒ‰åŒ¹é…åº¦æ’åº
        activated.sort(key=lambda x: x[1], reverse=True)
        
        # è¿”å›å‰ 5 ä¸ªæœ€ç›¸å…³çš„æŠ€èƒ½
        return [skill for skill, score in activated[:5]]
    
    def _calculate_relevance_score(
        self,
        skill: AgentSkill,
        context: str,
        task_description: str
    ) -> float:
        """è®¡ç®—æŠ€èƒ½ç›¸å…³æ€§åˆ†æ•°"""
        score = 0.0
        
        # æ£€æŸ¥æ¿€æ´»å…³é”®è¯
        text = (context + " " + task_description).lower()
        for keyword in skill.activation_keywords:
            if keyword.lower() in text:
                score += 0.2
        
        # æ£€æŸ¥æ ‡ç­¾åŒ¹é…
        # è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤æ‚çš„åŒ¹é…é€»è¾‘
        
        return min(score, 1.0)
    
    def inject_skills_into_prompt(
        self,
        base_prompt: str,
        activated_skills: List[AgentSkill]
    ) -> str:
        """å°†æ¿€æ´»çš„æŠ€èƒ½æ³¨å…¥åˆ°æç¤ºè¯ä¸­"""
        if not activated_skills:
            return base_prompt
        
        skills_content = "\n\n## ç›¸å…³ä¸“ä¸šçŸ¥è¯†\n\n"
        for skill in activated_skills:
            skills_content += f"### {skill.name}\n{skill.content}\n\n"
        
        return base_prompt + skills_content
```

#### 2.2 åˆ›å»ºå†…ç½®æŠ€èƒ½ç¤ºä¾‹

```markdown
# agent_skills/extension/romance_writing.md

---
name: è¨€æƒ…å°è¯´å†™ä½œæŠ€å·§
description: ä¸“ä¸šè¨€æƒ…å°è¯´å†™ä½œçŸ¥è¯†å’ŒæŠ€å·§
tags: [genre, romance, writing]
activation_keywords: [è¨€æƒ…, çˆ±æƒ…, æ‹çˆ±, æ„Ÿæƒ…çº¿, æƒ…æ„Ÿ]
---

## è¨€æƒ…å°è¯´æ ¸å¿ƒè¦ç´ 

### æƒ…æ„Ÿå‘å±•
- æƒ…æ„Ÿçº¿åº”è¯¥å¾ªåºæ¸è¿›ï¼Œæœ‰èµ·æ‰¿è½¬åˆ
- é¿å…ä¸€è§é’Ÿæƒ…ï¼ˆé™¤éæ˜¯ç‰¹å®šè®¾å®šï¼‰
- é€šè¿‡äº‹ä»¶å’Œäº’åŠ¨æ¨è¿›æ„Ÿæƒ…å‘å±•

### è§’è‰²å¡‘é€ 
- ä¸»è§’è¦æœ‰æ˜ç¡®çš„æ€§æ ¼ç‰¹å¾å’Œæˆé•¿å¼§çº¿
- é…è§’è¦æœ‰è‡ªå·±çš„æ•…äº‹çº¿ï¼Œä¸èƒ½åªæ˜¯å·¥å…·äºº
- åæ´¾è¦æœ‰åˆç†çš„åŠ¨æœº

### å†²çªè®¾è®¡
- å¤–éƒ¨å†²çªï¼šå®¶åº­ã€ç¤¾ä¼šã€ç¯å¢ƒç­‰
- å†…éƒ¨å†²çªï¼šæ€§æ ¼ã€ä»·å€¼è§‚ã€è¿‡å»ç»å†ç­‰
- æƒ…æ„Ÿå†²çªï¼šè¯¯ä¼šã€å«‰å¦’ã€ä¸å®‰å…¨æ„Ÿç­‰

### èŠ‚å¥æ§åˆ¶
- æƒ…æ„Ÿé«˜æ½®è¦åˆç†åˆ†å¸ƒ
- ç”œå® å’Œè™å¿ƒè¦å¹³è¡¡
- é¿å…è¿‡åº¦æ‹–æ²“æˆ–è¿‡å¿«å‘å±•

## å¸¸è§é—®é¢˜

1. **æ„Ÿæƒ…çº¿å•è–„**ï¼šå¢åŠ æƒ…æ„Ÿç»†èŠ‚å’Œå†…å¿ƒæå†™
2. **è§’è‰²è„¸è°±åŒ–**ï¼šç»™è§’è‰²æ›´å¤šç»´åº¦çš„æ€§æ ¼ç‰¹å¾
3. **å†²çªä¸å¤Ÿ**ï¼šå¢åŠ å†…å¤–å†²çªçš„å±‚æ¬¡
```

### æ–¹æ¡ˆä¸‰ï¼šæ–œæ å‘½ä»¤ç³»ç»Ÿé›†æˆ

#### 3.1 åˆ›å»ºæ–œæ å‘½ä»¤å¤„ç†å™¨

```python
# core/slash_commands.py

from typing import Dict, List, Optional, Callable, Any
from enum import Enum
import re
import logging

logger = logging.getLogger(__name__)

class SlashCommand:
    """æ–œæ å‘½ä»¤"""
    
    def __init__(
        self,
        name: str,
        description: str,
        handler: Callable,
        aliases: List[str] = None,
        parameters: List[Dict] = None
    ):
        self.name = name
        self.description = description
        self.handler = handler
        self.aliases = aliases or []
        self.parameters = parameters or []
    
    def matches(self, command_text: str) -> bool:
        """æ£€æŸ¥å‘½ä»¤æ˜¯å¦åŒ¹é…"""
        command_text = command_text.strip().lower()
        if command_text.startswith(f"/{self.name}"):
            return True
        for alias in self.aliases:
            if command_text.startswith(f"/{alias}"):
                return True
        return False
    
    async def execute(self, command_text: str, context: Dict) -> Any:
        """æ‰§è¡Œå‘½ä»¤"""
        # è§£æå‚æ•°
        args = self._parse_args(command_text)
        return await self.handler(args, context)
    
    def _parse_args(self, command_text: str) -> Dict:
        """è§£æå‘½ä»¤å‚æ•°"""
        # ç®€å•çš„å‚æ•°è§£æå®ç°
        parts = command_text.split()
        args = {}
        for i, param in enumerate(self.parameters):
            if i + 1 < len(parts):
                args[param['name']] = parts[i + 1]
        return args

class SlashCommandProcessor:
    """æ–œæ å‘½ä»¤å¤„ç†å™¨"""
    
    def __init__(self, workflow_manager=None, card_manager=None):
        self.workflow_manager = workflow_manager
        self.card_manager = card_manager
        self.commands: Dict[str, SlashCommand] = {}
        self._register_default_commands()
    
    def _register_default_commands(self):
        """æ³¨å†Œé»˜è®¤å‘½ä»¤"""
        # /constitution
        self.register_command(SlashCommand(
            name="constitution",
            description="å»ºç«‹æˆ–ç¼–è¾‘åˆ›ä½œåŸåˆ™",
            handler=self._handle_constitution,
            aliases=["const", "åŸåˆ™"]
        ))
        
        # /specify
        self.register_command(SlashCommand(
            name="specify",
            description="å®šä¹‰æ•…äº‹éœ€æ±‚è§„èŒƒ",
            handler=self._handle_specify,
            aliases=["spec", "è§„èŒƒ", "éœ€æ±‚"]
        ))
        
        # /clarify
        self.register_command(SlashCommand(
            name="clarify",
            description="æ¾„æ¸…æ­§ä¹‰ï¼Œç”Ÿæˆå…³é”®é—®é¢˜",
            handler=self._handle_clarify,
            aliases=["clar", "æ¾„æ¸…", "é—®é¢˜"]
        ))
        
        # /plan
        self.register_command(SlashCommand(
            name="plan",
            description="ç”Ÿæˆåˆ›ä½œè®¡åˆ’",
            handler=self._handle_plan,
            aliases=["è®¡åˆ’", "è§„åˆ’"]
        ))
        
        # /tasks
        self.register_command(SlashCommand(
            name="tasks",
            description="ç®¡ç†ä»»åŠ¡åˆ—è¡¨",
            handler=self._handle_tasks,
            aliases=["task", "ä»»åŠ¡"]
        ))
        
        # /write
        self.register_command(SlashCommand(
            name="write",
            description="å¼€å§‹å†™ä½œ",
            handler=self._handle_write,
            aliases=["å†™ä½œ", "å†™"]
        ))
        
        # /analyze
        self.register_command(SlashCommand(
            name="analyze",
            description="éªŒè¯è´¨é‡å’Œä¸€è‡´æ€§",
            handler=self._handle_analyze,
            aliases=["analysis", "éªŒè¯", "åˆ†æ"]
        ))
    
    def register_command(self, command: SlashCommand):
        """æ³¨å†Œå‘½ä»¤"""
        self.commands[command.name] = command
        for alias in command.aliases:
            self.commands[alias] = command
    
    async def process(self, command_text: str, context: Dict) -> Dict:
        """å¤„ç†å‘½ä»¤"""
        command_text = command_text.strip()
        
        if not command_text.startswith("/"):
            return {"error": "å‘½ä»¤å¿…é¡»ä»¥ / å¼€å¤´"}
        
        # æŸ¥æ‰¾åŒ¹é…çš„å‘½ä»¤
        for command in self.commands.values():
            if command.matches(command_text):
                try:
                    result = await command.execute(command_text, context)
                    return {
                        "success": True,
                        "command": command.name,
                        "result": result
                    }
                except Exception as e:
                    logger.error(f"æ‰§è¡Œå‘½ä»¤å¤±è´¥: {e}")
                    return {
                        "success": False,
                        "error": str(e)
                    }
        
        return {"error": f"æœªçŸ¥å‘½ä»¤: {command_text.split()[0]}"}
    
    async def _handle_constitution(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /constitution å‘½ä»¤"""
        # å®ç°åˆ›å»ºæˆ–ç¼–è¾‘åˆ›ä½œåŸåˆ™çš„é€»è¾‘
        pass
    
    async def _handle_specify(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /specify å‘½ä»¤"""
        # å®ç°å®šä¹‰æ•…äº‹éœ€æ±‚çš„é€»è¾‘
        pass
    
    async def _handle_clarify(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /clarify å‘½ä»¤"""
        # å®ç°æ¾„æ¸…æ­§ä¹‰çš„é€»è¾‘
        pass
    
    async def _handle_plan(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /plan å‘½ä»¤"""
        # å®ç°ç”Ÿæˆåˆ›ä½œè®¡åˆ’çš„é€»è¾‘
        pass
    
    async def _handle_tasks(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /tasks å‘½ä»¤"""
        # å®ç°ä»»åŠ¡ç®¡ç†çš„é€»è¾‘
        pass
    
    async def _handle_write(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /write å‘½ä»¤"""
        # å®ç°å†™ä½œçš„é€»è¾‘
        pass
    
    async def _handle_analyze(self, args: Dict, context: Dict) -> Dict:
        """å¤„ç† /analyze å‘½ä»¤"""
        # å®ç°è´¨é‡éªŒè¯çš„é€»è¾‘
        pass
    
    def list_commands(self) -> List[Dict]:
        """åˆ—å‡ºæ‰€æœ‰å¯ç”¨å‘½ä»¤"""
        unique_commands = {}
        for name, command in self.commands.items():
            if command.name not in unique_commands:
                unique_commands[command.name] = command
        
        return [
            {
                "name": cmd.name,
                "description": cmd.description,
                "aliases": cmd.aliases
            }
            for cmd in unique_commands.values()
        ]
```

## ğŸ“Š é›†æˆä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

1. âœ… **ä¸ƒæ­¥æ–¹æ³•è®ºå·¥ä½œæµ** - æä¾›ç»“æ„åŒ–åˆ›ä½œæµç¨‹
2. âœ… **Agent Skills ç³»ç»Ÿ** - æ¨¡å—åŒ–çŸ¥è¯†ç®¡ç†
3. âœ… **æ–œæ å‘½ä»¤ç³»ç»Ÿ** - å¿«é€Ÿè®¿é—®å¸¸ç”¨åŠŸèƒ½

### ä¸­ä¼˜å…ˆçº§ï¼ˆåç»­å®æ–½ï¼‰

4. â³ **è´¨é‡ä¿è¯å¢å¼º** - é›†æˆåˆ°ä¸ƒæ­¥æ–¹æ³•è®ºçš„ analyze é˜¶æ®µ
5. â³ **æŠ€èƒ½è‡ªåŠ¨æ¿€æ´»ä¼˜åŒ–** - æ”¹è¿›æŠ€èƒ½é€‰æ‹©ç®—æ³•
6. â³ **å‘½ä»¤è‡ªåŠ¨è¡¥å…¨** - å‰ç«¯æ”¯æŒå‘½ä»¤æç¤º

### ä½ä¼˜å…ˆçº§ï¼ˆå¯é€‰ï¼‰

7. â¸ï¸ **æŠ€èƒ½å¸‚åœº** - åˆ†äº«å’Œä¸‹è½½æŠ€èƒ½
8. â¸ï¸ **å‘½ä»¤æ’ä»¶ç³»ç»Ÿ** - æ”¯æŒè‡ªå®šä¹‰å‘½ä»¤

## ğŸ”— ä¸ç°æœ‰åŠŸèƒ½é›†æˆ

### ä¸ NovelForge åŠŸèƒ½é›†æˆ

- **ä¸ƒæ­¥æ–¹æ³•è®º** â†” **é›ªèŠ±å¼åˆ›ä½œæµç¨‹**ï¼šå¯ä»¥ç»“åˆä½¿ç”¨
- **Agent Skills** â†” **è‡ªç”±ä¸Šä¸‹æ–‡æ³¨å…¥**ï¼šæŠ€èƒ½å¯ä»¥ä½œä¸ºä¸Šä¸‹æ–‡æ³¨å…¥
- **æ–œæ å‘½ä»¤** â†” **çµæ„ŸåŠ©æ‰‹**ï¼šå‘½ä»¤å¯ä»¥åœ¨å¯¹è¯ä¸­ä½¿ç”¨

### ä¸ç°æœ‰ Agent é›†æˆ

- **PlannerAgent** â†” **ä¸ƒæ­¥æ–¹æ³•è®º**ï¼šplan é˜¶æ®µå¯ä»¥ä½¿ç”¨ PlannerAgent
- **AnalystAgent** â†” **analyze é˜¶æ®µ**ï¼šanalyze é˜¶æ®µå¯ä»¥ä½¿ç”¨ AnalystAgent
- **StylistAgent** â†” **Agent Skills**ï¼šé£æ ¼æŠ€èƒ½å¯ä»¥ä½œä¸º Agent Skill

## ğŸ“ å®æ–½æ­¥éª¤

1. **é˜¶æ®µä¸€**ï¼šå®ç°ä¸ƒæ­¥æ–¹æ³•è®ºå·¥ä½œæµåŸºç¡€æ¡†æ¶
2. **é˜¶æ®µäºŒ**ï¼šå®ç° Agent Skills ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½
3. **é˜¶æ®µä¸‰**ï¼šå®ç°æ–œæ å‘½ä»¤ç³»ç»Ÿ
4. **é˜¶æ®µå››**ï¼šé›†æˆåˆ°ç°æœ‰å·¥ä½œæµå’Œ API
5. **é˜¶æ®µäº”**ï¼šå‰ç«¯ç•Œé¢æ”¯æŒ
6. **é˜¶æ®µå…­**ï¼šæµ‹è¯•å’Œä¼˜åŒ–

## ğŸ“š å‚è€ƒèµ„æº

- [NovelWeave GitHub](https://github.com/wordflowlab/novelweave)
- [novel-writer æ–¹æ³•è®º](https://github.com/wordflowlab/novel-writer)
- [Agent Skills ç”¨æˆ·æŒ‡å—](https://github.com/wordflowlab/novelweave/docs/agent-skills)

---

**æœ€åæ›´æ–°**ï¼š2025-01-XX


